"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const uuid_1 = require("uuid");
const ss = require("socket.io-stream");
const PendingRpcCalls = {};
const FunctionHandlers = {};
class RpcService {
    constructor(socket) {
        this._socket = null;
        this._socket = socket;
        this.socketHandlers();
    }
    bindFn(name, fn) {
        if (FunctionHandlers.hasOwnProperty(name)) {
            console.warn('Overriding function ' + name);
        }
        FunctionHandlers[name] = fn;
    }
    callFn(name, args) {
        const rpc_call_id = (0, uuid_1.v4)();
        const rpcRequest = {
            id: rpc_call_id,
            functionName: name,
            functionArgs: args,
        };
        PendingRpcCalls[rpc_call_id] = {
            request: rpcRequest,
            request_start_time: new Date(),
        };
        const rpc_call_promise = new Promise((resolve, reject) => {
            PendingRpcCalls[rpc_call_id]['promise'] = {
                resolve,
                reject,
            };
            if (rpcRequest.functionArgs.hasOwnProperty('stream')) {
                let dataStream = rpcRequest.functionArgs.stream;
                const outgoingStream = ss.createStream();
                delete rpcRequest.functionArgs.stream;
                ss(this._socket).emit('rpc:request:stream', outgoingStream, rpcRequest);
                dataStream.pipe(outgoingStream);
                return;
            }
            this._socket.emit('rpc:request', rpcRequest);
        });
        return rpc_call_promise;
    }
    rpcRequestHandler(stream, rpcRequest) {
        let { id, functionName: handlerName, functionArgs, ...rest } = rpcRequest;
        if (!FunctionHandlers.hasOwnProperty(handlerName)) {
            if (FunctionHandlers.hasOwnProperty('*')) {
                console.debug("Calling default '*' handler since function name not explicitly found in handlers");
                handlerName = '*';
            }
            else {
                this._socket.emit('rpc:response', {
                    id,
                    status: 404,
                    data: { error: 'please check function name, function not found' },
                });
                return;
            }
        }
        let response = null;
        try {
            if (stream === null) {
                response = FunctionHandlers[handlerName](rpcRequest.functionName, functionArgs);
            }
            else {
                response = FunctionHandlers[handlerName](rpcRequest.functionName, stream, functionArgs);
            }
            if (typeof response?.then === 'function') {
                response
                    .then((promiseResponse) => {
                    this._socket.emit('rpc:response', {
                        id,
                        status: 200,
                        data: promiseResponse,
                    });
                })
                    .catch((error) => {
                    this._socket.emit('rpc:response', {
                        id,
                        status: 500,
                        data: error,
                    });
                });
            }
            else if (response.hasOwnProperty('stream')) {
                const data = response.data;
                const status = response.status;
                const outgoingStream = ss.createStream();
                ss(this._socket).emit('rpc:response:stream', outgoingStream, {
                    id,
                    status,
                    ...data,
                });
                response.stream.pipe(outgoingStream);
            }
            else {
                this._socket.emit('rpc:response', {
                    id,
                    status: 200,
                    data: response,
                });
            }
        }
        catch (error) {
            this._socket.emit('rpc:response', {
                id,
                status: 500,
                data: error,
            });
        }
    }
    socketHandlers() {
        this._socket.on('rpc:response', (rpcResponse) => {
            const { id, ...userResponse } = rpcResponse;
            if (PendingRpcCalls.hasOwnProperty(id)) {
                if (userResponse.status === 200) {
                    PendingRpcCalls[id]['promise'].resolve(userResponse);
                }
                else {
                    PendingRpcCalls[id]['promise'].reject(userResponse);
                }
                delete PendingRpcCalls[id];
            }
        });
        this._socket.on('rpc:request', (rpcRequest) => this.rpcRequestHandler(null, rpcRequest));
        ss(this._socket).on('rpc:request:stream', (stream, rpcRequest) => this.rpcRequestHandler(stream, rpcRequest));
        ss(this._socket).on('rpc:response:stream', (stream, rpcResponse) => {
            const { id, ...userResponse } = rpcResponse;
            PendingRpcCalls[id]['promise'].resolve(stream, userResponse);
            delete PendingRpcCalls[id];
        });
    }
}
exports.default = RpcService;
//# sourceMappingURL=rpc.service.js.map