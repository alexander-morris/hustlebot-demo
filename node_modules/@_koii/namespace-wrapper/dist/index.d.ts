/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { Transaction, Keypair, PublicKey } from '@_koii/web3.js';
import Datastore from 'nedb-promises';
import { promises as fsPromises, WriteStream } from 'fs';
import { TaskState, TaskNode, TaskSubmissionState, TaskDistributionInfo, LogLevel, TaskStateOptions, TaskType } from './types';
declare const TASK_ID: string | undefined;
declare const MAIN_ACCOUNT_PUBKEY: string;
declare const SECRET_KEY: string;
declare const K2_NODE_URL: string;
declare const SERVICE_URL: string;
declare const STAKE: number;
declare const TASK_NODE_PORT: number;
declare const app: import("express-serve-static-core").Express;
declare const _server: import("http").Server<typeof import("http").IncomingMessage, typeof import("http").ServerResponse>;
declare const taskNodeAdministered: boolean;
declare class NamespaceWrapper implements TaskNode {
    private db;
    testingMainSystemAccount: Keypair | null;
    testingStakingSystemAccount: Keypair | null;
    testingTaskState: TaskState | null;
    testingDistributionList: any;
    constructor();
    initializeDB(): Promise<void>;
    getDb(): Promise<Datastore<any>>;
    storeGet(key: string): Promise<string | null>;
    storeSet(key: string, value: string): Promise<void>;
    fs(method: keyof typeof fsPromises, path: string, ...args: any[]): Promise<any>;
    fsStaking(method: keyof typeof fsPromises, path: string, ...args: any[]): Promise<any>;
    fsWriteStream(imagepath: string): Promise<WriteStream | void>;
    fsReadStream(imagepath: string): Promise<Buffer | void>;
    payloadSigning(body: Record<string, unknown>): Promise<string | void>;
    bs58Encode(data: Uint8Array): Promise<string>;
    bs58Decode(data: string): Promise<Uint8Array>;
    decodePayload(payload: Uint8Array): string;
    verifySignature(signedMessage: string, pubKey: string): Promise<{
        data?: string;
        error?: string;
    }>;
    getSlot(): Promise<number>;
    getNodes(url: string): Promise<any>;
    getRpcUrl(): Promise<string | void>;
    getProgramAccounts(): Promise<any>;
    sendAndConfirmTransactionWrapper(transaction: Transaction, signers: Keypair[]): Promise<void | string>;
    sendTransaction(serviceNodeAccount: PublicKey, beneficiaryAccount: PublicKey, amount: number): Promise<void | string>;
    claimReward(stakePotAccount: PublicKey, beneficiaryAccount: PublicKey, claimerKeypair: Keypair): Promise<void>;
    stakeOnChain(taskStateInfoPublicKey: PublicKey, stakingAccKeypair: Keypair, stakePotAccount: PublicKey, stakeAmount: number): Promise<void | string>;
    logMessage(level: LogLevel, message: string, action: string): Promise<boolean>;
    /**
     * This logger function is used to log the task erros , warnings and logs on desktop-node
     * @param {level} enum // Receive method ["Log", "Warn", "Error"]
     enum LogLevel {
     Log = 'log',
     Warn = 'warn',
     Error = 'error',
     }
     * @param {message} string // log, error or warning message
     * @returns {boolean} // true if the message is logged successfully otherwise false
     */
    logger(level: LogLevel, message: string, action: string): Promise<boolean>;
    checkSubmissionAndUpdateRound(submissionValue: string | undefined, round: number): Promise<void>;
    getTaskState(options: TaskStateOptions): Promise<TaskState | null>;
    getTaskStateById(taskId: string, task_type: TaskType, options: TaskStateOptions): Promise<TaskState | null>;
    getTaskLevelDBPath(): Promise<string>;
    getBasePath(): Promise<string>;
    getRound(): Promise<number>;
    defaultTaskSetup(): Promise<void>;
    getTaskSubmissionInfo(round: number): Promise<TaskSubmissionState | null>;
    getSubmitterAccount(): Promise<Keypair | null>;
    getMainAccountPubkey(): Promise<string | null>;
    getTaskNodeVersion(): Promise<string>;
    auditSubmission(candidatePubkey: PublicKey, isValid: boolean, voterKeypair: Keypair, round: number): Promise<void>;
    validateAndVoteOnNodes(validate: (submissionValue: string, round: number, nodePublicKey: string) => Promise<boolean>, round: number, useRandomSampling?: boolean, uploadToIPFS?: boolean): Promise<void | string>;
    fetchWithTimeout: (url: string, timeout?: number) => Promise<Response>;
    retrieveThroughHttpGateway(cid: string, fileName?: string): Promise<string>;
    distributionListSubmissionOnChain(round: number): Promise<void | string>;
    uploadDistributionList(distributionList: Record<string, any>, round: number): Promise<boolean | null>;
    getTaskDistributionInfo(round: number): Promise<TaskDistributionInfo | null>;
    distributionListAuditSubmission(candidatePubkey: PublicKey, isValid: boolean, voterKeypair: Keypair, round: number): Promise<void>;
    validateAndVoteOnDistributionList(validateDistribution: (submissionValue: string, round: number, nodePublicKey: string) => Promise<boolean>, round: number): Promise<void | string>;
    getDistributionList(publicKey: string, round: number): Promise<any | null>;
    nodeSelectionDistributionList(round: number, isPreviousFailed: boolean): Promise<string | void>;
    getAverageSlotTime(): Promise<number>;
    payoutTrigger(round: number): Promise<void>;
    selectAndGenerateDistributionList(submitDistributionList: (round: number) => Promise<void>, round: number, isPreviousRoundFailed: boolean): Promise<void>;
    getTestingStakingWallet(): Keypair;
}
declare const namespaceWrapper: NamespaceWrapper;
export { namespaceWrapper, taskNodeAdministered, app, TASK_ID, MAIN_ACCOUNT_PUBKEY, SECRET_KEY, K2_NODE_URL, SERVICE_URL, STAKE, TASK_NODE_PORT, _server, };
