"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports._server = exports.TASK_NODE_PORT = exports.STAKE = exports.SERVICE_URL = exports.K2_NODE_URL = exports.SECRET_KEY = exports.MAIN_ACCOUNT_PUBKEY = exports.TASK_ID = exports.app = exports.taskNodeAdministered = exports.namespaceWrapper = void 0;
const axios_1 = __importDefault(require("axios"));
const crypto_1 = require("crypto");
const crypto_2 = __importDefault(require("crypto"));
const web3_js_1 = require("@_koii/web3.js");
const nedb_promises_1 = __importDefault(require("nedb-promises"));
const fs_1 = require("fs");
const bs58_1 = __importDefault(require("bs58"));
const tweetnacl_1 = __importDefault(require("tweetnacl"));
const express_1 = __importDefault(require("express"));
const dotenv_1 = __importDefault(require("dotenv"));
const body_parser_1 = __importDefault(require("body-parser"));
const types_1 = require("./types");
dotenv_1.default.config();
const TASK_NAME = process.argv[2] || 'Local';
const TASK_ID = process.argv[3];
exports.TASK_ID = TASK_ID;
const EXPRESS_PORT = parseInt(process.argv[4], 10) || 3000;
const MAIN_ACCOUNT_PUBKEY = process.argv[6] || '';
exports.MAIN_ACCOUNT_PUBKEY = MAIN_ACCOUNT_PUBKEY;
const SECRET_KEY = process.argv[7] || '';
exports.SECRET_KEY = SECRET_KEY;
const K2_NODE_URL = process.argv[8] || '"https://testnet.koii.network"';
exports.K2_NODE_URL = K2_NODE_URL;
const SERVICE_URL = process.argv[9] || '';
exports.SERVICE_URL = SERVICE_URL;
const STAKE = parseFloat(process.argv[10]) || 0;
exports.STAKE = STAKE;
const TASK_NODE_PORT = parseInt(process.argv[11], 10) || 0;
exports.TASK_NODE_PORT = TASK_NODE_PORT;
const app = (0, express_1.default)();
exports.app = app;
console.log('SETTING UP EXPRESS');
app.use(body_parser_1.default.urlencoded({ limit: '50mb', extended: false }));
app.use(body_parser_1.default.json({ limit: '50mb' }));
app.use((req, res, next) => {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, PATCH, DELETE');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
    res.setHeader('Access-Control-Allow-Credentials', 'false');
    if (req.method === 'OPTIONS') {
        return res.sendStatus(204);
    }
    next();
});
app.get('/', (req, res) => {
    res.json({ status: 200, message: 'Running' });
});
const _server = app.listen(EXPRESS_PORT, () => {
    console.log(`${TASK_NAME} listening on port ${EXPRESS_PORT}`);
});
exports._server = _server;
const taskNodeAdministered = !!TASK_ID;
exports.taskNodeAdministered = taskNodeAdministered;
const BASE_ROOT_URL = `http://localhost:${TASK_NODE_PORT}/namespace-wrapper`;
let connection;
class NamespaceWrapper {
    constructor() {
        this.db = null;
        this.testingMainSystemAccount = null;
        this.testingStakingSystemAccount = null;
        this.testingTaskState = null;
        this.testingDistributionList = null;
        this.fetchWithTimeout = (url, timeout = 60000) => {
            const controller = new AbortController();
            return new Promise((resolve, reject) => {
                const timeoutId = setTimeout(() => {
                    controller === null || controller === void 0 ? void 0 : controller.abort();
                    reject(new Error('Request timed out'));
                }, timeout);
                fetch(url, { signal: controller.signal })
                    .then((response) => {
                    clearTimeout(timeoutId);
                    resolve(response);
                })
                    .catch((error) => {
                    if (error.name === 'AbortError') {
                        reject(new Error('Request was aborted'));
                    }
                    else {
                        reject(error);
                    }
                });
            });
        };
        if (taskNodeAdministered) {
            this.initializeDB();
        }
        else {
            this.db = nedb_promises_1.default.create('./localKOIIDB.db');
            this.defaultTaskSetup();
        }
    }
    initializeDB() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.db)
                return;
            try {
                if (taskNodeAdministered) {
                    const path = yield this.getTaskLevelDBPath();
                    this.db = nedb_promises_1.default.create(path);
                }
                else {
                    this.db = nedb_promises_1.default.create('./localKOIIDB.db');
                }
            }
            catch (e) {
                this.db = nedb_promises_1.default.create(`../namespace/${TASK_ID}/KOIILevelDB.db`);
            }
        });
    }
    getDb() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.db)
                return this.db;
            yield this.initializeDB();
            return this.db;
        });
    }
    storeGet(key) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.initializeDB();
                const resp = yield this.db.findOne({ key });
                return resp ? resp[key] : null;
            }
            catch (e) {
                console.error(e);
                return null;
            }
        });
    }
    storeSet(key, value) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.initializeDB();
                yield this.db.update({ key }, { [key]: value, key }, { upsert: true });
            }
            catch (e) {
                console.error(e);
                return undefined;
            }
        });
    }
    fs(method, path, ...args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                return yield genericHandler('fs', method, path, ...args);
            }
            else {
                const fsMethod = fs_1.promises[method];
                return fsMethod(path, ...args);
            }
        });
    }
    fsStaking(method, path, ...args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                return yield genericHandler('fsStaking', method, path, ...args);
            }
            else {
                const fsMethod = fs_1.promises[method];
                return fsMethod(path, ...args);
            }
        });
    }
    fsWriteStream(imagepath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                return yield genericHandler('fsWriteStream', imagepath);
            }
            else {
                const writer = (0, fs_1.createWriteStream)(imagepath);
                return writer;
            }
        });
    }
    fsReadStream(imagepath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                return yield genericHandler('fsReadStream', imagepath);
            }
            else {
                const file = (0, fs_1.readFileSync)(imagepath);
                return file;
            }
        });
    }
    payloadSigning(body) {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                return yield genericHandler('signData', body);
            }
            else {
                const msg = new TextEncoder().encode(JSON.stringify(body));
                const signedMessage = tweetnacl_1.default.sign(msg, this.testingMainSystemAccount.secretKey);
                return yield this.bs58Encode(signedMessage);
            }
        });
    }
    bs58Encode(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return bs58_1.default.encode(data);
        });
    }
    bs58Decode(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Uint8Array(bs58_1.default.decode(data));
        });
    }
    decodePayload(payload) {
        return new TextDecoder().decode(payload);
    }
    verifySignature(signedMessage, pubKey) {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                return yield genericHandler('verifySignedData', signedMessage, pubKey);
            }
            else {
                try {
                    const payload = tweetnacl_1.default.sign.open(yield this.bs58Decode(signedMessage), yield this.bs58Decode(pubKey));
                    if (!payload)
                        return { error: 'Invalid signature' };
                    return { data: this.decodePayload(payload) };
                }
                catch (e) {
                    console.error(e);
                    return { error: `Verification failed: ${e}` };
                }
            }
        });
    }
    getSlot() {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                const response = yield genericHandler('getCurrentSlot');
                if (typeof response === 'number') {
                    return response;
                }
                else {
                    console.error('Error getting slot:', response);
                    return 0; // or handle error appropriately
                }
            }
            else {
                return 100;
            }
        });
    }
    getNodes(url) {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                return yield genericHandler('getNodes', url);
            }
            else {
                console.log('Cannot call getNodes in testing mode');
            }
        });
    }
    getRpcUrl() {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                return yield genericHandler('getRpcUrl');
            }
            else {
                console.log('Cannot call get URL in testing mode');
            }
        });
    }
    getProgramAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                return yield genericHandler('getProgramAccounts');
            }
            else {
                console.log('Cannot call getProgramAccounts in testing mode');
            }
        });
    }
    sendAndConfirmTransactionWrapper(transaction, signers) {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                console.log('Cannot call sendTransaction in testing mode');
                return;
            }
            const blockhash = (yield connection.getRecentBlockhash('finalized'))
                .blockhash;
            transaction.recentBlockhash = blockhash;
            transaction.feePayer = new web3_js_1.PublicKey(MAIN_ACCOUNT_PUBKEY);
            return yield genericHandler('sendAndConfirmTransactionWrapper', transaction.serialize({
                requireAllSignatures: false,
                verifySignatures: false,
            }), signers);
        });
    }
    sendTransaction(serviceNodeAccount, beneficiaryAccount, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!taskNodeAdministered) {
                console.log('Cannot call sendTransaction in testing mode');
                return;
            }
            return yield genericHandler('sendTransaction', serviceNodeAccount, beneficiaryAccount, amount);
        });
    }
    claimReward(stakePotAccount, beneficiaryAccount, claimerKeypair) {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                console.log('Cannot call sendTransaction in testing mode');
                return;
            }
            return yield genericHandler('claimReward', stakePotAccount, beneficiaryAccount, claimerKeypair);
        });
    }
    stakeOnChain(taskStateInfoPublicKey, stakingAccKeypair, stakePotAccount, stakeAmount) {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                return yield genericHandler('stakeOnChain', taskStateInfoPublicKey, stakingAccKeypair, stakePotAccount, stakeAmount);
            }
            else {
                this.testingTaskState.stake_list[this.testingStakingSystemAccount.publicKey.toBase58()] = stakeAmount;
                this.testingTaskState.ip_address_list[this.testingStakingSystemAccount.publicKey.toBase58()] = 'http://127.0.0.1:3000';
            }
        });
    }
    logMessage(level, message, action) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (level) {
                case types_1.LogLevel.Log:
                    console.log(message, action);
                    break;
                case types_1.LogLevel.Warn:
                    console.warn(message, action);
                    break;
                case types_1.LogLevel.Error:
                    console.error(message, action);
                    break;
                default:
                    console.log(`Invalid log level: ${level}. The log levels can be log, warn or error`);
                    return false;
            }
            return true;
        });
    }
    /**
     * This logger function is used to log the task erros , warnings and logs on desktop-node
     * @param {level} enum // Receive method ["Log", "Warn", "Error"]
     enum LogLevel {
     Log = 'log',
     Warn = 'warn',
     Error = 'error',
     }
     * @param {message} string // log, error or warning message
     * @returns {boolean} // true if the message is logged successfully otherwise false
     */
    logger(level, message, action) {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                return yield genericHandler('logger', level, message, action);
            }
            else {
                return yield this.logMessage(level, message, action);
            }
        });
    }
    checkSubmissionAndUpdateRound() {
        return __awaiter(this, arguments, void 0, function* (submissionValue = 'default', round) {
            if (taskNodeAdministered) {
                yield genericHandler('checkSubmissionAndUpdateRound', submissionValue, round);
            }
            else {
                if (!this.testingTaskState.submissions[round]) {
                    this.testingTaskState.submissions[round] = {};
                }
                this.testingTaskState.submissions[round][this.testingStakingSystemAccount.publicKey.toBase58()] = {
                    submission_value: submissionValue,
                    slot: 100,
                    round,
                };
            }
        });
    }
    getTaskState(options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                const response = yield genericHandler('getTaskState', options);
                if (typeof response === 'number') {
                    // Handle error response (numbers)
                    console.log('Error in getting task state', response);
                    return null;
                }
                else {
                    // Handle successful response
                    return response;
                }
            }
            else {
                return this.testingTaskState;
            }
        });
    }
    getTaskStateById(taskId, task_type, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                const response = yield genericHandler('getTaskStateById', taskId, options, task_type);
                if (typeof response === 'number') {
                    // Handle error response (numbers)
                    console.error('Error in getting task state', response);
                    return null;
                }
                else {
                    // Handle successful response
                    return response;
                }
            }
            else {
                // get task state from K2
                const connection = new web3_js_1.Connection(process.env.K2_URL || 'https://testnet.koii.network', 'confirmed');
                if (!options)
                    options = {};
                const { is_submission_required = false, is_distribution_required = false, is_available_balances_required = false, is_stake_list_required = false, } = options;
                if (task_type === 'KOII') {
                    try {
                        const taskAccountInfo = yield connection.getTaskAccountInfo(new web3_js_1.PublicKey(taskId), is_submission_required, is_distribution_required, is_available_balances_required, is_stake_list_required, 'base64');
                        if (!taskAccountInfo) {
                            console.error('Error getting task account info');
                            return null;
                        }
                        return JSON.parse(taskAccountInfo.data.toString('utf-8'));
                    }
                    catch (error) {
                        console.error('Error in fetching task state', error);
                        return null;
                    }
                }
                else if (task_type === 'KPL') {
                    const bincode_js = yield Promise.resolve().then(() => __importStar(require(
                    /* webpackIgnore: true */
                    '../webasm_bincode_deserializer/bincode_js')));
                    const borsh_bpf_js_deserialize = bincode_js.borsh_bpf_js_deserialize;
                    try {
                        const accountInfo = yield connection.getAccountInfo(new web3_js_1.PublicKey(taskId));
                        if (!accountInfo) {
                            console.error('Error in getting task account info');
                            return null;
                        }
                        const buffer = accountInfo.data;
                        const taskState = borsh_bpf_js_deserialize(buffer);
                        return parseTaskState(taskState, is_submission_required, is_distribution_required, is_available_balances_required, is_stake_list_required);
                    }
                    catch (error) {
                        console.error('Error in fetching task state', error);
                        return null;
                    }
                }
                else {
                    throw new Error('Task type is required');
                }
            }
        });
    }
    getTaskLevelDBPath() {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                return yield genericHandler('getTaskLevelDBPath');
            }
            else {
                return './KOIIDB';
            }
        });
    }
    getBasePath() {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                return yield genericHandler('getBasePath');
            }
            else {
                return './';
            }
        });
    }
    getRound() {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                return yield genericHandler('getRound');
            }
            else {
                return 1;
            }
        });
    }
    defaultTaskSetup() {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                yield genericHandler('defaultTaskSetup');
            }
            else {
                if (this.testingTaskState)
                    return;
                this.testingMainSystemAccount = new web3_js_1.Keypair();
                this.testingStakingSystemAccount = this.getTestingStakingWallet();
                this.testingDistributionList = {};
                this.testingTaskState = {
                    task_id: '',
                    task_name: 'DummyTestState',
                    task_manager: '',
                    is_allowlisted: false,
                    is_active: false,
                    task_audit_program: 'test',
                    stake_pot_account: '',
                    total_bounty_amount: 10000000000,
                    bounty_amount_per_round: 1000000000,
                    current_round: 0,
                    available_balances: {},
                    stake_list: {},
                    task_metadata: 'test',
                    task_description: 'Dummy Task state for testing flow',
                    submissions: {},
                    submissions_audit_trigger: {},
                    total_stake_amount: 50000000000,
                    minimum_stake_amount: 5000000000,
                    ip_address_list: {},
                    round_time: 600,
                    starting_slot: 0,
                    audit_window: 200,
                    submission_window: 200,
                    task_executable_network: 'IPFS',
                    distribution_rewards_submission: {},
                    distributions_audit_trigger: {},
                    distributions_audit_record: {},
                    task_vars: 'test',
                    koii_vars: 'test',
                    is_migrated: false,
                    migrated_to: '',
                    allowed_failed_distributions: 0,
                };
            }
        });
    }
    getTaskSubmissionInfo(round) {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                const taskSubmissionInfo = yield genericHandler('getTaskSubmissionInfo', round);
                if (typeof taskSubmissionInfo === 'object' &&
                    'error' in taskSubmissionInfo) {
                    return null;
                }
                return taskSubmissionInfo;
            }
            else {
                return this.testingTaskState;
            }
        });
    }
    getSubmitterAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                const submitterAccountResp = yield genericHandler('getSubmitterAccount');
                return web3_js_1.Keypair.fromSecretKey(Uint8Array.from(Object.values(submitterAccountResp._keypair.secretKey)));
            }
            else {
                return this.testingStakingSystemAccount;
            }
        });
    }
    getMainAccountPubkey() {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                return MAIN_ACCOUNT_PUBKEY;
            }
            else {
                return this.testingMainSystemAccount.publicKey.toBase58();
            }
        });
    }
    getTaskNodeVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                return yield genericHandler('getTaskNodeVersion');
            }
            else {
                return '1.11.19';
            }
        });
    }
    auditSubmission(candidatePubkey, isValid, voterKeypair, round) {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                yield genericHandler('auditSubmission', candidatePubkey, isValid, round);
            }
            else {
                if (this.testingTaskState.submissions_audit_trigger[round] &&
                    this.testingTaskState.submissions_audit_trigger[round][candidatePubkey.toBase58()]) {
                    this.testingTaskState.submissions_audit_trigger[round][candidatePubkey.toBase58()].votes.push({
                        is_valid: isValid,
                        voter: voterKeypair.publicKey,
                        slot: 100,
                    });
                }
                else {
                    this.testingTaskState.submissions_audit_trigger[round] = {
                        [candidatePubkey.toBase58()]: {
                            trigger_by: this.testingStakingSystemAccount.publicKey,
                            slot: 100,
                            votes: [],
                        },
                    };
                }
            }
        });
    }
    validateAndVoteOnNodes(validate_1, round_1, useRandomSampling_1) {
        return __awaiter(this, arguments, void 0, function* (validate, round, useRandomSampling, uploadToIPFS = false) {
            var _a;
            console.log('******/  IN VOTING /******');
            useRandomSampling = useRandomSampling !== null && useRandomSampling !== void 0 ? useRandomSampling : false;
            let taskAccountDataJSON = null;
            try {
                taskAccountDataJSON = yield this.getTaskSubmissionInfo(round);
            }
            catch (error) {
                console.error('Error in getting submissions for the round', error);
            }
            if (taskAccountDataJSON == null) {
                console.log('No submissions found for the round', round);
                return;
            }
            // console.log(
            //   `Fetching the submissions of round ${round}`,
            //   taskAccountDataJSON.submissions[round],
            // )
            const submissions = taskAccountDataJSON.submissions[round];
            if (submissions == null) {
                console.log(`No submissions found in round ${round}`);
                return `No submissions found in round ${round}`;
            }
            else {
                const keys = Object.keys(submissions);
                const values = Object.values(submissions);
                const size = values.length;
                console.log('Submissions from last round: ', keys, values, size);
                let indices = [];
                if (useRandomSampling == true) {
                    const numberOfChecks = Math.min(5, size);
                    let uniqueIndices = new Set();
                    while (uniqueIndices.size < numberOfChecks) {
                        const randomIndex = Math.floor(Math.random() * size);
                        uniqueIndices.add(randomIndex);
                    }
                    indices = Array.from(uniqueIndices);
                }
                else {
                    indices = Array.from({ length: size }, (_, i) => i);
                }
                const submitterAccountKeyPair = yield this.getSubmitterAccount();
                const submitterPubkey = submitterAccountKeyPair.publicKey.toBase58();
                for (let index of indices) {
                    const candidatePublicKey = keys[index];
                    console.log('FOR CANDIDATE KEY', candidatePublicKey);
                    const candidateKeyPairPublicKey = new web3_js_1.PublicKey(candidatePublicKey);
                    if (candidatePublicKey === submitterPubkey && taskNodeAdministered) {
                        console.log('YOU CANNOT VOTE ON YOUR OWN SUBMISSIONS');
                        continue;
                    }
                    try {
                        console.log('SUBMISSION VALUE TO CHECK', values[index].submission_value);
                        let isValid = false;
                        if (uploadToIPFS) {
                            // call the function to validate signature and get the hash of data
                            const cid = values[index].submission_value;
                            const data = JSON.parse(yield this.retrieveThroughHttpGateway(cid, `submissionValues${round}.json`));
                            const receivedHash = yield this.verifySignature(data.signedMessage, candidatePublicKey);
                            console.log('Received hash', receivedHash);
                            // calculate the hash from the file contents
                            const calculatedHash = crypto_2.default
                                .createHash('sha256')
                                .update(data.submission)
                                .digest('hex');
                            console.log('Calculated hash', calculatedHash);
                            // Remove the extra quotes from receivedHash.data
                            const normalizedReceivedHash = (_a = receivedHash.data) === null || _a === void 0 ? void 0 : _a.replace(/"/g, '');
                            console.log('Normalized received hash', normalizedReceivedHash);
                            //  compare if the calculated hash is equal to the received hash
                            if (calculatedHash == normalizedReceivedHash) {
                                isValid = yield validate(data.submission, round, candidatePublicKey);
                                console.log(`Voting ${isValid} to ${candidatePublicKey}`);
                            }
                            else {
                                console.error('INVALID HASH');
                                console.log('RAISING AUDIT / VOTING FALSE');
                                const response = yield this.auditSubmission(candidateKeyPairPublicKey, false, submitterAccountKeyPair, round);
                                console.log('RESPONSE FROM AUDIT FUNCTION', response);
                            }
                        }
                        else {
                            isValid = yield validate(values[index].submission_value, round, candidatePublicKey);
                            console.log(`Voting ${isValid} to ${candidatePublicKey}`);
                        }
                        if (isValid) {
                            const submissions_audit_trigger = taskAccountDataJSON.submissions_audit_trigger[round];
                            console.log('SUBMIT AUDIT TRIGGER', submissions_audit_trigger);
                            if (submissions_audit_trigger &&
                                submissions_audit_trigger[candidatePublicKey]) {
                                console.log('VOTING TRUE ON AUDIT');
                                const response = yield this.auditSubmission(candidateKeyPairPublicKey, isValid, submitterAccountKeyPair, round);
                                console.log('RESPONSE FROM AUDIT FUNCTION', response);
                            }
                        }
                        else {
                            console.log('RAISING AUDIT / VOTING FALSE');
                            const response = yield this.auditSubmission(candidateKeyPairPublicKey, isValid, submitterAccountKeyPair, round);
                            console.log('RESPONSE FROM AUDIT FUNCTION', response);
                        }
                    }
                    catch (err) {
                        console.log('ERROR IN ELSE CONDITION', err);
                    }
                }
            }
        });
    }
    retrieveThroughHttpGateway(cid_1) {
        return __awaiter(this, arguments, void 0, function* (cid, fileName = '') {
            console.log('use IPFS HTTP gateway');
            const listOfIpfsGatewaysUrls = [
                `https://koii-k2-task-metadata.s3.us-east-2.amazonaws.com/${cid}/${fileName}`,
                `https://${cid}.ipfs.w3s.link/${fileName}`,
                `https://ipfs-gateway.koii.live/ipfs/${cid}/${fileName}`,
                `https://${cid}.ipfs.dweb.link/${fileName}`,
                `https://gateway.ipfs.io/ipfs/${cid}/${fileName}`,
                `https://ipfs.io/ipfs/${cid}/${fileName}`,
                `https://ipfs.eth.aragon.network/ipfs/${cid}/${fileName}`,
            ];
            for (const url of listOfIpfsGatewaysUrls) {
                try {
                    const response = yield this.fetchWithTimeout(url);
                    const fileContent = yield response.text();
                    const couldNotFetchActualFileContent = fileContent.startsWith('<');
                    if (!couldNotFetchActualFileContent) {
                        return fileContent;
                    }
                    console.log(`Gateway failed at ${url}, trying next if available.`);
                }
                catch (error) {
                    console.error(`Error fetching from ${url}:`, error);
                }
            }
            throw Error(`Failed to get ${cid} from IPFS`);
        });
    }
    distributionListSubmissionOnChain(round) {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                return yield genericHandler('distributionListSubmissionOnChain', round);
            }
            else {
                if (!this.testingTaskState.distribution_rewards_submission[round]) {
                    this.testingTaskState.distribution_rewards_submission[round] = {};
                }
                this.testingTaskState.distribution_rewards_submission[round][this.testingStakingSystemAccount.publicKey.toBase58()] = {
                    submission_value: this.testingStakingSystemAccount.publicKey.toBase58(),
                    slot: 200,
                    round: 1,
                };
            }
        });
    }
    uploadDistributionList(distributionList, round) {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                return yield genericHandler('uploadDistributionList', distributionList, round);
            }
            else {
                if (!this.testingDistributionList[round]) {
                    this.testingDistributionList[round] = {};
                }
                this.testingDistributionList[round][this.testingStakingSystemAccount.publicKey.toBase58()] = Buffer.from(JSON.stringify(distributionList));
                return true;
            }
        });
    }
    getTaskDistributionInfo(round) {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                const taskDistributionInfo = yield genericHandler('getTaskDistributionInfo', round);
                if (typeof taskDistributionInfo === 'object' &&
                    'error' in taskDistributionInfo) {
                    return null;
                }
                return taskDistributionInfo;
            }
            else {
                return this.testingTaskState;
            }
        });
    }
    distributionListAuditSubmission(candidatePubkey, isValid, voterKeypair, round) {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                yield genericHandler('distributionListAuditSubmission', candidatePubkey, isValid, round);
            }
            else {
                if (this.testingTaskState.distributions_audit_trigger[round] &&
                    this.testingTaskState.distributions_audit_trigger[round][candidatePubkey.toBase58()]) {
                    this.testingTaskState.distributions_audit_trigger[round][candidatePubkey.toBase58()].votes.push({
                        is_valid: isValid,
                        voter: voterKeypair.publicKey,
                        slot: 100,
                    });
                }
                else {
                    this.testingTaskState.distributions_audit_trigger[round] = {
                        [candidatePubkey.toBase58()]: {
                            trigger_by: this.testingStakingSystemAccount.publicKey,
                            slot: 100,
                            votes: [],
                        },
                    };
                }
            }
        });
    }
    validateAndVoteOnDistributionList(validateDistribution, round) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log('******/  IN VOTING OF DISTRIBUTION LIST /******');
            //isPreviousRoundFailed = isPreviousRoundFailed ?? false
            // let tasknodeVersionSatisfied = false
            // const taskNodeVersion = await this.getTaskNodeVersion()
            // if (semver.gte(taskNodeVersion, '1.11.19')) {
            //   tasknodeVersionSatisfied = true
            // }
            let taskAccountDataJSON = null;
            try {
                taskAccountDataJSON = yield this.getTaskDistributionInfo(round);
            }
            catch (error) {
                console.error('Error in getting distributions for the round', error);
            }
            if (taskAccountDataJSON == null) {
                console.log('No distribution submissions found for the round', round);
                return;
            }
            console.log(`Fetching the Distribution submissions of round ${round}`, taskAccountDataJSON.distribution_rewards_submission[round]);
            const submissions = taskAccountDataJSON === null || taskAccountDataJSON === void 0 ? void 0 : taskAccountDataJSON.distribution_rewards_submission[round];
            if (submissions == null || submissions == undefined) {
                console.log(`No submisssions found in round ${round}`);
                return `No submisssions found in round ${round}`;
            }
            else {
                const keys = Object.keys(submissions);
                const values = Object.values(submissions);
                const size = values.length;
                console.log('Distribution Submissions from last round: ', keys, values, size);
                let isValid;
                const submitterAccountKeyPair = yield this.getSubmitterAccount();
                const submitterPubkey = submitterAccountKeyPair === null || submitterAccountKeyPair === void 0 ? void 0 : submitterAccountKeyPair.publicKey.toBase58();
                for (let i = 0; i < size; i++) {
                    let candidatePublicKey = keys[i];
                    console.log('FOR CANDIDATE KEY', candidatePublicKey);
                    let candidateKeyPairPublicKey = new web3_js_1.PublicKey(keys[i]);
                    if (candidatePublicKey == submitterPubkey && taskNodeAdministered) {
                        console.log('YOU CANNOT VOTE ON YOUR OWN DISTRIBUTION SUBMISSIONS');
                    }
                    else {
                        try {
                            console.log('DISTRIBUTION SUBMISSION VALUE TO CHECK', values[i].submission_value);
                            isValid = yield validateDistribution(values[i].submission_value, round, candidatePublicKey);
                            console.log(`Voting ${isValid} to ${candidatePublicKey}`);
                            if (isValid) {
                                const distributions_audit_trigger = taskAccountDataJSON.distributions_audit_trigger[round];
                                console.log('SUBMIT DISTRIBUTION AUDIT TRIGGER', distributions_audit_trigger);
                                if (distributions_audit_trigger &&
                                    distributions_audit_trigger[candidatePublicKey]) {
                                    console.log('VOTING TRUE ON DISTRIBUTION AUDIT');
                                    const response = yield this.distributionListAuditSubmission(candidateKeyPairPublicKey, isValid, submitterAccountKeyPair, round);
                                    console.log('RESPONSE FROM DISTRIBUTION AUDIT FUNCTION', response);
                                }
                            }
                            else if (isValid == false) {
                                console.log('RAISING AUDIT / VOTING FALSE ON DISTRIBUTION');
                                const response = yield this.distributionListAuditSubmission(candidateKeyPairPublicKey, isValid, submitterAccountKeyPair, round);
                                console.log('RESPONSE FROM DISTRIBUTION AUDIT FUNCTION', response);
                            }
                        }
                        catch (err) {
                            console.log('ERROR IN ELSE CONDITION FOR DISTRIBUTION', err);
                        }
                    }
                }
            }
        });
    }
    getDistributionList(publicKey, round) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log('GET DISTRIBUTION LIST CALLED');
            if (taskNodeAdministered) {
                const response = yield genericHandler('getDistributionList', publicKey, round);
                if (response.error) {
                    return null;
                }
                return response;
            }
            else {
                const submissionValAcc = this.testingTaskState.distribution_rewards_submission[round][this.testingStakingSystemAccount.publicKey.toBase58()].submission_value;
                console.log('testingDistributionList', this.testingDistributionList);
                return this.testingDistributionList[round][submissionValAcc];
            }
        });
    }
    nodeSelectionDistributionList(round, isPreviousFailed) {
        return __awaiter(this, void 0, void 0, function* () {
            let taskAccountDataJSON = null;
            try {
                taskAccountDataJSON = yield this.getTaskSubmissionInfo(round);
            }
            catch (error) {
                console.error('Task submission not found', error);
                return;
            }
            if (taskAccountDataJSON == null) {
                console.error('Task state not found');
                return;
            }
            console.log('EXPECTED ROUND', round);
            const submissions = taskAccountDataJSON.submissions[round];
            if (submissions == null) {
                console.log('No submisssions found in N-1 round');
                return 'No submisssions found in N-1 round';
            }
            else {
                let keys = [];
                const latestRounds = [round, round - 1, round - 2].filter((r) => r >= 0);
                const promises = latestRounds.map((r) => __awaiter(this, void 0, void 0, function* () {
                    if (r == round) {
                        return new Set(Object.keys(submissions));
                    }
                    else {
                        let roundSubmissions = null;
                        try {
                            roundSubmissions = yield this.getTaskSubmissionInfo(r);
                            if (roundSubmissions && roundSubmissions.submissions[r]) {
                                return new Set(Object.keys(roundSubmissions.submissions[r]));
                            }
                        }
                        catch (error) {
                            console.error('Error in getting submissions for the round', error);
                        }
                        return new Set();
                    }
                }));
                const keySets = yield Promise.all(promises);
                keys =
                    keySets.length > 0
                        ? [...keySets[0]].filter((key) => keySets.every((set) => set.has(key)))
                        : [];
                if (keys.length == 0) {
                    console.log('No common keys found in last 3 rounds');
                    keys = Object.keys(submissions);
                }
                console.log('KEYS', keys.length);
                const values = keys.map((key) => submissions[key]);
                let size = keys.length;
                console.log('Submissions from N-2 round: ', size);
                try {
                    const distributionData = yield this.getTaskDistributionInfo(round);
                    const audit_record = distributionData === null || distributionData === void 0 ? void 0 : distributionData.distributions_audit_record;
                    if (audit_record && audit_record[round] == 'PayoutFailed') {
                        console.log('ROUND DATA', audit_record[round]);
                        const submitterList = distributionData.distribution_rewards_submission[round];
                        const submitterKeys = Object.keys(submitterList);
                        console.log('SUBMITTER KEYS', submitterKeys);
                        const submitterSize = submitterKeys.length;
                        console.log('SUBMITTER SIZE', submitterSize);
                        for (let j = 0; j < submitterSize; j++) {
                            console.log('SUBMITTER KEY CANDIDATE', submitterKeys[j]);
                            const id = keys.indexOf(submitterKeys[j]);
                            console.log('ID', id);
                            if (id != -1) {
                                keys.splice(id, 1);
                                values.splice(id, 1);
                                size--;
                            }
                        }
                        console.log('KEYS FOR HASH CALC', keys.length);
                    }
                }
                catch (error) {
                    console.log('Error in getting distribution data', error);
                }
                const ValuesString = JSON.stringify(values);
                const hashDigest = (0, crypto_1.createHash)('sha256').update(ValuesString).digest('hex');
                console.log('HASH DIGEST', hashDigest);
                const calculateScore = (str = '') => {
                    return str.split('').reduce((acc, val) => {
                        return acc + val.charCodeAt(0);
                    }, 0);
                };
                const compareASCII = (str1, str2) => {
                    const firstScore = calculateScore(str1);
                    const secondScore = calculateScore(str2);
                    return Math.abs(firstScore - secondScore);
                };
                const selectedNode = {
                    score: 0,
                    pubkey: '',
                };
                let score = 0;
                if (isPreviousFailed) {
                    let leastScore = -Infinity;
                    let secondLeastScore = -Infinity;
                    for (let i = 0; i < size; i++) {
                        const candidateSubmissionJson = {};
                        candidateSubmissionJson[keys[i]] = values[i];
                        const candidateSubmissionString = JSON.stringify(candidateSubmissionJson);
                        const candidateSubmissionHash = (0, crypto_1.createHash)('sha256')
                            .update(candidateSubmissionString)
                            .digest('hex');
                        const candidateScore = compareASCII(hashDigest, candidateSubmissionHash);
                        if (candidateScore > leastScore) {
                            secondLeastScore = leastScore;
                            leastScore = candidateScore;
                        }
                        else if (candidateScore > secondLeastScore) {
                            secondLeastScore = candidateScore;
                            selectedNode.score = candidateScore;
                            selectedNode.pubkey = keys[i];
                        }
                    }
                }
                else {
                    for (let i = 0; i < size; i++) {
                        const candidateSubmissionJson = {};
                        candidateSubmissionJson[keys[i]] = values[i];
                        const candidateSubmissionString = JSON.stringify(candidateSubmissionJson);
                        const candidateSubmissionHash = (0, crypto_1.createHash)('sha256')
                            .update(candidateSubmissionString)
                            .digest('hex');
                        const candidateScore = compareASCII(hashDigest, candidateSubmissionHash);
                        if (candidateScore > score) {
                            score = candidateScore;
                            selectedNode.score = candidateScore;
                            selectedNode.pubkey = keys[i];
                        }
                    }
                }
                console.log('SELECTED NODE OBJECT', selectedNode);
                return selectedNode.pubkey;
            }
        });
    }
    getAverageSlotTime() {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                try {
                    return yield genericHandler('getAverageSlotTime');
                }
                catch (error) {
                    console.error('Error getting average slot time', error);
                    return 400;
                }
            }
            else {
                return 400;
            }
        });
    }
    payoutTrigger(round) {
        return __awaiter(this, void 0, void 0, function* () {
            if (taskNodeAdministered) {
                yield genericHandler('payloadTrigger', round);
            }
            else {
                console.log('Payout Trigger only handles positive flows (Without audits)');
                round = 1;
                const submissionValAcc = this.testingDistributionList[round][this.testingStakingSystemAccount.publicKey.toBase58()].submission_value;
                this.testingTaskState.available_balances =
                    this.testingDistributionList[round][submissionValAcc];
            }
        });
    }
    selectAndGenerateDistributionList(submitDistributionList, round, isPreviousRoundFailed) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log('SelectAndGenerateDistributionList called');
            const selectedNode = yield this.nodeSelectionDistributionList(round, isPreviousRoundFailed);
            console.log('Selected Node', selectedNode);
            const submitPubKey = yield this.getSubmitterAccount();
            if (!selectedNode || !submitPubKey)
                return;
            console.log('Selected Node', selectedNode);
            console.log('Submitter PubKey', submitPubKey.publicKey.toBase58());
            console.log('Round', round);
            if (selectedNode === (submitPubKey === null || submitPubKey === void 0 ? void 0 : submitPubKey.publicKey.toBase58())) {
                console.log('IN SELECTED NODE CONDITION AND CALLING SUBMIT DISTRIBUTION');
                yield submitDistributionList(round);
                const taskState = yield this.getTaskState({});
                if (taskState == null) {
                    console.error('Task state not found');
                    return;
                }
                const avgSlotTime = yield this.getAverageSlotTime();
                if (avgSlotTime == null) {
                    console.error('Avg slot time not found');
                    return;
                }
                setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                    yield this.payoutTrigger(round);
                }), (taskState.audit_window + taskState.submission_window) * avgSlotTime);
            }
        });
    }
    getTestingStakingWallet() {
        if (process.env.STAKING_WALLET_PATH) {
            const wallet = (0, fs_1.readFileSync)(process.env.STAKING_WALLET_PATH, 'utf-8');
            return web3_js_1.Keypair.fromSecretKey(Uint8Array.from(JSON.parse(wallet)));
        }
        else {
            return new web3_js_1.Keypair();
        }
    }
}
function genericHandler(...args) {
    return __awaiter(this, void 0, void 0, function* () {
        var _a;
        try {
            const response = yield axios_1.default.post(BASE_ROOT_URL, {
                args,
                taskId: TASK_ID,
                secret: SECRET_KEY,
            });
            if (response.status === 200) {
                return response.data.response;
            }
            else {
                console.error(response.status, response.data);
                return { error: response.data };
            }
        }
        catch (err) {
            console.error(`Error in genericHandler: "${args[0]}"`, err.message);
            console.error((_a = err === null || err === void 0 ? void 0 : err.response) === null || _a === void 0 ? void 0 : _a.data);
            return { error: err };
        }
    });
}
function parseTaskState(taskState, is_submission_required = false, is_distribution_required = false, is_available_balances_required = false, is_stake_list_required = false) {
    if (is_stake_list_required) {
        taskState.stake_list = objectify(taskState.stake_list, true);
    }
    else {
        taskState.stake_list = {};
    }
    taskState.ip_address_list = objectify(taskState.ip_address_list, true);
    if (is_distribution_required) {
        taskState.distributions_audit_record = objectify(taskState.distributions_audit_record, true);
        taskState.distributions_audit_trigger = objectify(taskState.distributions_audit_trigger, true);
        taskState.distribution_rewards_submission = objectify(taskState.distribution_rewards_submission, true);
    }
    else {
        taskState.distributions_audit_record = {};
        taskState.distributions_audit_trigger = {};
        taskState.distribution_rewards_submission = {};
    }
    if (is_submission_required) {
        taskState.submissions = objectify(taskState.submissions, true);
        taskState.submissions_audit_trigger = objectify(taskState.submissions_audit_trigger, true);
    }
    else {
        taskState.submissions = {};
        taskState.submissions_audit_trigger = {};
    }
    if (is_available_balances_required) {
        taskState.available_balances = objectify(taskState.available_balances, true);
    }
    else {
        taskState.available_balances = {};
    }
    return taskState;
}
function objectify(data, recursive = false) {
    if (data instanceof Map) {
        const obj = Object.fromEntries(data);
        if (recursive) {
            for (const key in obj) {
                if (obj[key] instanceof Map) {
                    obj[key] = objectify(obj[key], true);
                }
                else if (typeof obj[key] === 'object' && obj[key] !== null) {
                    obj[key] = objectify(obj[key], true);
                }
            }
        }
        return obj;
    }
    return data;
}
const namespaceWrapper = new NamespaceWrapper();
exports.namespaceWrapper = namespaceWrapper;
if (taskNodeAdministered) {
    namespaceWrapper.getRpcUrl().then((rpcUrl) => {
        console.log(rpcUrl, 'RPC URL');
        if (typeof rpcUrl === 'string') {
            connection = new web3_js_1.Connection(rpcUrl, 'confirmed');
        }
    });
}
