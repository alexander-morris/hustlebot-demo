var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { namespaceWrapper } from "@_koii/namespace-wrapper";
import { getTaskManager } from "../taskManager.js";
class Distribution {
    constructor() {
        /**
         * Generates and submits the distribution list for a given round
         *
         */
        this.submitDistributionList = (round) => __awaiter(this, void 0, void 0, function* () {
            console.log(`SUBMIT DISTRIBUTION LIST CALLED WITH ROUND ${round}`);
            try {
                const distributionList = yield this.generateDistributionList(round);
                if (!Object.keys(distributionList).length) {
                    return console.log("NO DISTRIBUTION LIST GENERATED");
                }
                const decider = yield namespaceWrapper.uploadDistributionList(distributionList, round);
                console.log("DECIDER", decider);
                if (decider) {
                    const response = yield namespaceWrapper.distributionListSubmissionOnChain(round);
                    console.log("RESPONSE FROM DISTRIBUTION LIST", response);
                }
            }
            catch (err) {
                console.log("ERROR IN SUBMIT DISTRIBUTION", err);
            }
        });
        /**
         * Validates the distribution list for a given round in your logic
         */
        this.validateDistribution = (distributionListSubmitter, round, _nodePublicKey) => __awaiter(this, void 0, void 0, function* () {
            if (distributionListSubmitter == null) {
                return true;
            }
            try {
                console.log("DISTRIBUTION LIST SUBMITTER", distributionListSubmitter);
                const rawDistributionList = yield namespaceWrapper.getDistributionList(distributionListSubmitter, round);
                const fetchedDistributionList = JSON.parse(rawDistributionList);
                console.log("FETCHED DISTRIBUTION LIST", fetchedDistributionList);
                const generateDistributionList = yield this.generateDistributionList(round);
                if (Object.keys(generateDistributionList).length === 0) {
                    console.log("UNABLE TO GENERATE DISTRIBUTION LIST");
                    return true;
                }
                console.log("COMPARE DISTRIBUTION LIST", fetchedDistributionList, generateDistributionList);
                const result = yield this.shallowEqual(fetchedDistributionList, generateDistributionList);
                console.log("RESULT", result);
                return result;
            }
            catch (err) {
                console.log("ERROR IN VALIDATING DISTRIBUTION", err);
                return false;
            }
        });
    }
    selectAndGenerateDistributionList(round_1) {
        return __awaiter(this, arguments, void 0, function* (round, isPreviousRoundFailed = false) {
            console.log(`SELECT AND GENERATE DISTRIBUTION LIST CALLED WITH ROUND ${round}`);
            yield namespaceWrapper.selectAndGenerateDistributionList(this.submitDistributionList, round, isPreviousRoundFailed);
        });
    }
    /**
     * Audits the distribution list for a given round
     *
     */
    auditDistribution(round) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log("AUDIT DISTRIBUTION CALLED WITHIN ROUND: ", round);
            yield namespaceWrapper.validateAndVoteOnDistributionList(this.validateDistribution, round);
        });
    }
    /**
     * User-end Distribution List Check Ensure that the distribution list will be correct format
     */
    userEndDistributionListCheck(candidates, bountyAmountPerRound, user_submitted_distributionList) {
        return __awaiter(this, void 0, void 0, function* () {
            // get candidates public keys
            const candidatesPublicKeys = candidates.map((candidate) => candidate.publicKey);
            // get the user submitted distribution list keys
            const userSubmittedDistributionListKeys = Object.keys(user_submitted_distributionList);
            // check if all the candidates are in the user submitted distribution list
            const allCandidatesInUserSubmittedDistributionList = candidatesPublicKeys.every((candidatePublicKey) => userSubmittedDistributionListKeys.includes(candidatePublicKey));
            if (!allCandidatesInUserSubmittedDistributionList) {
                // return a distribution list with 0 for all candidate
                console.log("FATAL ERROR PREVENTION MECHANISM TRIGGERED: NOT ALL CANDIDATES IN USER SUBMITTED DISTRIBUTION LIST");
                return Object.fromEntries(candidatesPublicKeys.map((candidatePublicKey) => [candidatePublicKey, 0]));
            }
            // Check if the total amount exceeds the bounty amount per round
            const totalBountyAmount = Object.values(user_submitted_distributionList).reduce((acc, curr) => acc + curr, 0);
            if (totalBountyAmount > bountyAmountPerRound) {
                // return a distribution list with 0 for all candidates
                console.log("FATAL ERROR PREVENTION MECHANISM TRIGGERED: TOTAL BOUNTY AMOUNT EXCEEDS BONUS AMOUNT PER ROUND");
                return Object.fromEntries(candidatesPublicKeys.map((candidatePublicKey) => [candidatePublicKey, 0]));
            }
            // check if the distribution list values are all integers
            const allValuesAreIntegers = Object.values(user_submitted_distributionList).every((value) => Number.isInteger(value));
            if (!allValuesAreIntegers) {
                console.log("FATAL ERROR PREVENTION MECHANISM TRIGGERED: DISTRIBUTION LIST VALUES ARE NOT INTEGERS");
                return Object.fromEntries(candidatesPublicKeys.map((candidatePublicKey) => [candidatePublicKey, 0]));
            }
            return user_submitted_distributionList;
        });
    }
    /**
     * Generates the distribution list for a given round in your logic
     */
    generateDistributionList(round) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                console.log("GENERATE DISTRIBUTION LIST CALLED WITH ROUND", round);
                let distributionList = {};
                let taskAccountDataJSON, taskStakeListJSON;
                try {
                    taskAccountDataJSON =
                        yield namespaceWrapper.getTaskSubmissionInfo(round);
                    taskStakeListJSON = yield namespaceWrapper.getTaskState({
                        is_stake_list_required: true,
                    });
                }
                catch (error) {
                    console.error("ERROR FETCHING TASK SUBMISSION DATA", error);
                    return distributionList;
                }
                if (!taskAccountDataJSON || !taskStakeListJSON) {
                    console.error("ERROR IN FETCHING TASK SUBMISSION DATA");
                    return distributionList;
                }
                if (!(taskAccountDataJSON === null || taskAccountDataJSON === void 0 ? void 0 : taskAccountDataJSON.submissions[round])) {
                    console.log(`NO SUBMISSIONS FOUND IN ROUND ${round}`);
                    return distributionList;
                }
                const submissions = taskAccountDataJSON.submissions[round];
                const submissions_audit_trigger = taskAccountDataJSON.submissions_audit_trigger[round];
                console.log(taskAccountDataJSON.submissions);
                if (!submissions) {
                    return distributionList;
                }
                const keys = Object.keys(submissions);
                const stakeList = taskStakeListJSON.stake_list;
                let candidates = [];
                keys.forEach((candidatePublicKey) => {
                    var _a, _b;
                    const votes = (_a = submissions_audit_trigger === null || submissions_audit_trigger === void 0 ? void 0 : submissions_audit_trigger[candidatePublicKey]) === null || _a === void 0 ? void 0 : _a.votes;
                    // initial vote was true, no audit triggered
                    let validVotes = 1;
                    if (votes) {
                        // tally votes from audit
                        validVotes = votes.reduce((acc, vote) => acc + (vote.is_valid ? 1 : -1), 0);
                    }
                    candidates.push({
                        publicKey: candidatePublicKey,
                        votes: validVotes,
                        stake: (_b = stakeList[candidatePublicKey]) !== null && _b !== void 0 ? _b : 0,
                    });
                });
                const taskManager = yield getTaskManager();
                distributionList = taskManager.makeDistributionList(candidates, taskStakeListJSON.bounty_amount_per_round, round);
                distributionList = yield this.userEndDistributionListCheck(candidates, taskStakeListJSON.bounty_amount_per_round, distributionList);
                let base = 0;
                let commissionPercent = 0;
                for (const candidate of candidates) {
                    const candidateReward = distributionList[candidate.publicKey];
                    if (!candidateReward) {
                        continue;
                    }
                    // if the candidate has a penalty, the task creator pays the commission from the slashed stake they receive
                    // otherwise candidate pays the commission from their rewards
                    // so we sum up the total rewards and penalties to get the total amount the commission is calculated from
                    if (candidateReward < 0) {
                        base -= candidateReward; // this makes the penalty positive
                    }
                    else {
                        base += candidateReward;
                    }
                    // we distribute the commission to the extension providers
                    for (const extension in taskManager.getExtensions()) {
                        const extensionConfig = taskManager.getExtensionConfig(extension);
                        const { percent: extPercent, publicKey: extPublicKey } = extensionConfig;
                        // each extension provider gets their percentage of the total commission
                        distributionList[extPublicKey] = base * extPercent;
                        // and we get the total commission percent to subtract from the candidate reward
                        commissionPercent += extPercent;
                    }
                    // we subtract the commission from the candidate reward
                    for (const candidate of candidates) {
                        const candidateReward = distributionList[candidate.publicKey];
                        if (!candidateReward) {
                            continue;
                        }
                        // but only if the candidate has a positive reward
                        // if the candidate has a penalty, the amount has already been taken from the task creator
                        if (candidateReward > 0) {
                            const commission = candidateReward * commissionPercent;
                            distributionList[candidate.publicKey] =
                                candidateReward - commission;
                        }
                    }
                }
                console.log("FINAL DISTRIBUTION LIST", distributionList);
                return distributionList;
            }
            catch (err) {
                console.log("ERROR GENERATING DISTRIBUTION LIST", err);
                return {};
            }
        });
    }
    /**
     * Compares two distribution lists for equality
     */
    shallowEqual(fetchedDistributionList, generatedDistributionList) {
        return __awaiter(this, void 0, void 0, function* () {
            const normalize = (distributionList) => typeof distributionList === "string"
                ? JSON.parse(distributionList)
                : distributionList;
            fetchedDistributionList = normalize(fetchedDistributionList);
            generatedDistributionList = normalize(generatedDistributionList);
            const keys1 = Object.keys(fetchedDistributionList);
            const keys2 = Object.keys(generatedDistributionList);
            return (keys1.length === keys2.length &&
                keys1.every((key) => fetchedDistributionList[key] === generatedDistributionList[key]));
        });
    }
}
const distribution = new Distribution();
export { distribution };
