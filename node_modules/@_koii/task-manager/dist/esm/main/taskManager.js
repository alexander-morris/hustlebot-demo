var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _TaskManager_extensionConfig, _TaskManager_extensions;
class TaskManager {
    constructor(customSetup = () => __awaiter(this, void 0, void 0, function* () { }), executeTask = () => __awaiter(this, void 0, void 0, function* () { }), fetchSubmission = () => __awaiter(this, void 0, void 0, function* () { return ""; }), auditSubmission = () => __awaiter(this, void 0, void 0, function* () { return false; }), makeDistributionList = () => ({}), setupRoutes = () => __awaiter(this, void 0, void 0, function* () { }), isInitialized = false) {
        this.customSetup = customSetup;
        this.executeTask = executeTask;
        this.fetchSubmission = fetchSubmission;
        this.auditSubmission = auditSubmission;
        this.makeDistributionList = makeDistributionList;
        this.setupRoutes = setupRoutes;
        this.isInitialized = isInitialized;
        _TaskManager_extensionConfig.set(this, {});
        _TaskManager_extensions.set(this, new Set());
    }
    initialize(userFunctions) {
        const [missingFunctions, notFunctions] = this.checkFunctions(userFunctions);
        if (missingFunctions.length > 0) {
            const functionPlural = missingFunctions.length > 1 ? "functions" : "function";
            throw new Error(`Missing required ${functionPlural}: ${missingFunctions.join("(), ")}()`);
        }
        if (notFunctions.length > 0) {
            const functionPlural = notFunctions.length > 1 ? "functions" : "a function";
            throw new Error(`Not ${functionPlural}: ${notFunctions.join("(), ")}()`);
        }
        const { setup, task, submission, audit, distribution, routes } = userFunctions;
        this.customSetup = setup;
        this.executeTask = task;
        this.fetchSubmission = submission;
        this.auditSubmission = audit;
        this.makeDistributionList = distribution;
        this.setupRoutes = routes;
        this.isInitialized = true;
    }
    checkFunctions(userFunctions) {
        const requiredFunctions = [
            "setup",
            "task",
            "submission",
            "audit",
            "distribution",
            "routes",
        ];
        const missingFunctions = [];
        const notFunctions = [];
        for (const func of requiredFunctions) {
            if (!userFunctions[func]) {
                missingFunctions.push(func);
            }
            else if (typeof userFunctions[func] !== "function") {
                notFunctions.push(func);
            }
        }
        return [missingFunctions, notFunctions];
    }
    registerExtension(extension, config) {
        __classPrivateFieldGet(this, _TaskManager_extensions, "f").add(extension);
        __classPrivateFieldGet(this, _TaskManager_extensionConfig, "f")[extension] = config;
    }
    getExtensions() {
        return Array.from(__classPrivateFieldGet(this, _TaskManager_extensions, "f"));
    }
    hasExtension(extension) {
        return __classPrivateFieldGet(this, _TaskManager_extensions, "f").has(extension);
    }
    getExtensionConfig(extension) {
        const config = __classPrivateFieldGet(this, _TaskManager_extensionConfig, "f")[extension];
        if (!config) {
            throw new Error(`Extension ${extension} is not registered.`);
        }
        return config;
    }
}
_TaskManager_extensionConfig = new WeakMap(), _TaskManager_extensions = new WeakMap();
const taskManager = new TaskManager();
export function initializeTaskManager(userFunctions) {
    taskManager.initialize(userFunctions);
}
export function getTaskManager() {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            if (taskManager.isInitialized) {
                resolve(taskManager);
                return;
            }
            const interval = setInterval(() => {
                if (taskManager.isInitialized) {
                    clearInterval(interval);
                    resolve(taskManager);
                }
            }, 100);
            setTimeout(() => {
                clearInterval(interval);
                reject(new Error("Task manager is not ready after 2 seconds."));
            }, 2000);
        });
    });
}
