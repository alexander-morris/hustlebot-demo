import { namespaceWrapper } from "@_koii/namespace-wrapper";
import { getTaskManager } from "../taskManager.js";
import type { DistributionList, Submitter } from "../../types/global.js";

class Distribution {
  /**
   * Generates and submits the distribution list for a given round
   *
   */

  async selectAndGenerateDistributionList(
    round: number,
    isPreviousRoundFailed = false,
  ): Promise<void> {
    console.log(
      `SELECT AND GENERATE DISTRIBUTION LIST CALLED WITH ROUND ${round}`,
    );
    await namespaceWrapper.selectAndGenerateDistributionList(
      this.submitDistributionList,
      round,
      isPreviousRoundFailed,
    );
  }
  submitDistributionList = async (round: number) => {
    console.log(`SUBMIT DISTRIBUTION LIST CALLED WITH ROUND ${round}`);
    try {
      const distributionList = await this.generateDistributionList(round);
      if (!Object.keys(distributionList).length) {
        return console.log("NO DISTRIBUTION LIST GENERATED");
      }
      const decider = await namespaceWrapper.uploadDistributionList(
        distributionList,
        round,
      );
      console.log("DECIDER", decider);
      if (decider) {
        const response =
          await namespaceWrapper.distributionListSubmissionOnChain(round);
        console.log("RESPONSE FROM DISTRIBUTION LIST", response);
      }
    } catch (err) {
      console.log("ERROR IN SUBMIT DISTRIBUTION", err);
    }
  };

  /**
   * Audits the distribution list for a given round
   *
   */
  async auditDistribution(round: number): Promise<void> {
    console.log("AUDIT DISTRIBUTION CALLED WITHIN ROUND: ", round);
    await namespaceWrapper.validateAndVoteOnDistributionList(
      this.validateDistribution,
      round,
    );
  }

  /**
   * User-end Distribution List Check Ensure that the distribution list will be correct format
   */
  async userEndDistributionListCheck(candidates: Submitter[], bountyAmountPerRound: number, user_submitted_distributionList: DistributionList): Promise<DistributionList> {
    // get candidates public keys
    const candidatesPublicKeys = candidates.map((candidate) => candidate.publicKey);
    // get the user submitted distribution list keys
    const userSubmittedDistributionListKeys = Object.keys(user_submitted_distributionList);
    // check if all the candidates are in the user submitted distribution list
    const allCandidatesInUserSubmittedDistributionList = candidatesPublicKeys.every((candidatePublicKey) => userSubmittedDistributionListKeys.includes(candidatePublicKey));
    if (!allCandidatesInUserSubmittedDistributionList) {
      // return a distribution list with 0 for all candidate
      console.log("FATAL ERROR PREVENTION MECHANISM TRIGGERED: NOT ALL CANDIDATES IN USER SUBMITTED DISTRIBUTION LIST");
      return Object.fromEntries(candidatesPublicKeys.map((candidatePublicKey) => [candidatePublicKey, 0]));
    }
    // Check if the total amount exceeds the bounty amount per round
    const totalBountyAmount = Object.values(user_submitted_distributionList).reduce((acc, curr) => acc + curr, 0);
    if (totalBountyAmount > bountyAmountPerRound) {
      // return a distribution list with 0 for all candidates
      console.log("FATAL ERROR PREVENTION MECHANISM TRIGGERED: TOTAL BOUNTY AMOUNT EXCEEDS BONUS AMOUNT PER ROUND");
      return Object.fromEntries(candidatesPublicKeys.map((candidatePublicKey) => [candidatePublicKey, 0]));
    }

    // check if the distribution list values are all integers
    const allValuesAreIntegers = Object.values(user_submitted_distributionList).every((value) => Number.isInteger(value));
    if (!allValuesAreIntegers) {
      console.log("FATAL ERROR PREVENTION MECHANISM TRIGGERED: DISTRIBUTION LIST VALUES ARE NOT INTEGERS");
      return Object.fromEntries(candidatesPublicKeys.map((candidatePublicKey) => [candidatePublicKey, 0]));
    }

    return user_submitted_distributionList
  }
  /**
   * Generates the distribution list for a given round in your logic
   */
  async generateDistributionList(round: number): Promise<DistributionList> {
    try {
      console.log("GENERATE DISTRIBUTION LIST CALLED WITH ROUND", round);
      let distributionList: DistributionList = {};

      let taskAccountDataJSON, taskStakeListJSON;
      try {
        taskAccountDataJSON =
          await namespaceWrapper.getTaskSubmissionInfo(round);
        taskStakeListJSON = await namespaceWrapper.getTaskState({
          is_stake_list_required: true,
        });
      } catch (error) {
        console.error("ERROR FETCHING TASK SUBMISSION DATA", error);
        return distributionList;
      }
      if (!taskAccountDataJSON || !taskStakeListJSON) {
        console.error("ERROR IN FETCHING TASK SUBMISSION DATA");
        return distributionList;
      }
      if (!taskAccountDataJSON?.submissions[round]) {
        console.log(`NO SUBMISSIONS FOUND IN ROUND ${round}`);
        return distributionList;
      }
      const submissions = taskAccountDataJSON.submissions[round];
      const submissions_audit_trigger =
        taskAccountDataJSON.submissions_audit_trigger[round];
      console.log(taskAccountDataJSON.submissions);
      if (!submissions) {
        return distributionList;
      }
      const keys = Object.keys(submissions);
      const stakeList = taskStakeListJSON.stake_list;
      let candidates: Submitter[] = [];
      keys.forEach((candidatePublicKey) => {
        const votes = submissions_audit_trigger?.[candidatePublicKey]?.votes;
        // initial vote was true, no audit triggered
        let validVotes = 1;
        if (votes) {
          // tally votes from audit
          validVotes = votes.reduce(
            (acc, vote) => acc + (vote.is_valid ? 1 : -1),
            0,
          );
        }
        candidates.push({
          publicKey: candidatePublicKey,
          votes: validVotes,
          stake: stakeList[candidatePublicKey] ?? 0,
        });
      });

      const taskManager = await getTaskManager();
      distributionList = taskManager.makeDistributionList(
        candidates,
        taskStakeListJSON.bounty_amount_per_round,
        round,
      );
      distributionList = await this.userEndDistributionListCheck(candidates, taskStakeListJSON.bounty_amount_per_round, distributionList);
      let base = 0;
      let commissionPercent = 0;
      for (const candidate of candidates) {
        const candidateReward = distributionList[candidate.publicKey];
        if (!candidateReward) {
          continue;
        }
        // if the candidate has a penalty, the task creator pays the commission from the slashed stake they receive
        // otherwise candidate pays the commission from their rewards
        // so we sum up the total rewards and penalties to get the total amount the commission is calculated from
        if (candidateReward < 0) {
          base -= candidateReward; // this makes the penalty positive
        } else {
          base += candidateReward;
        }
        // we distribute the commission to the extension providers
        for (const extension in taskManager.getExtensions()) {
          const extensionConfig = taskManager.getExtensionConfig(extension);
          const { percent: extPercent, publicKey: extPublicKey } =
            extensionConfig;
          // each extension provider gets their percentage of the total commission
          distributionList[extPublicKey] = base * extPercent;
          // and we get the total commission percent to subtract from the candidate reward
          commissionPercent += extPercent;
        }
        // we subtract the commission from the candidate reward
        for (const candidate of candidates) {
          const candidateReward = distributionList[candidate.publicKey];
          if (!candidateReward) {
            continue;
          }
          // but only if the candidate has a positive reward
          // if the candidate has a penalty, the amount has already been taken from the task creator
          if (candidateReward > 0) {
            const commission = candidateReward * commissionPercent;
            distributionList[candidate.publicKey] =
              candidateReward - commission;
          }
        }
      }
      console.log("FINAL DISTRIBUTION LIST", distributionList);
      return distributionList;
    } catch (err) {
      console.log("ERROR GENERATING DISTRIBUTION LIST", err);
      return {};
    }
  }

  /**
   * Validates the distribution list for a given round in your logic
   */
  validateDistribution = async (
    distributionListSubmitter: string,
    round: number,
    _nodePublicKey: string,
  ): Promise<boolean> => {
    if (distributionListSubmitter == null) {
      return true;
    }

    try {
      console.log("DISTRIBUTION LIST SUBMITTER", distributionListSubmitter);
      const rawDistributionList = await namespaceWrapper.getDistributionList(
        distributionListSubmitter,
        round,
      );
      const fetchedDistributionList: DistributionList =
        JSON.parse(rawDistributionList);
      console.log("FETCHED DISTRIBUTION LIST", fetchedDistributionList);
      const generateDistributionList =
        await this.generateDistributionList(round);

      if (Object.keys(generateDistributionList).length === 0) {
        console.log("UNABLE TO GENERATE DISTRIBUTION LIST");
        return true;
      }
      console.log(
        "COMPARE DISTRIBUTION LIST",
        fetchedDistributionList,
        generateDistributionList,
      );
      const result = await this.shallowEqual(
        fetchedDistributionList,
        generateDistributionList,
      );
      console.log("RESULT", result);
      return result;
    } catch (err) {
      console.log("ERROR IN VALIDATING DISTRIBUTION", err);
      return false;
    }
  };

  /**
   * Compares two distribution lists for equality
   */
  async shallowEqual(
    fetchedDistributionList: DistributionList,
    generatedDistributionList: DistributionList,
  ): Promise<boolean> {
    const normalize = (distributionList: DistributionList | string) =>
      typeof distributionList === "string"
        ? JSON.parse(distributionList)
        : distributionList;
    fetchedDistributionList = normalize(fetchedDistributionList);
    generatedDistributionList = normalize(generatedDistributionList);
    const keys1 = Object.keys(fetchedDistributionList);
    const keys2 = Object.keys(generatedDistributionList);
    return (
      keys1.length === keys2.length &&
      keys1.every(
        (key) =>
          fetchedDistributionList[key] === generatedDistributionList[key],
      )
    );
  }
}

const distribution = new Distribution();
export { distribution };
