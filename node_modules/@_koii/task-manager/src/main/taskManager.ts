import type {
  ExtensionConfig,
  ExtensionConfigs,
  UserFunctions,
} from "../types/taskManager.js";

class TaskManager {
  #extensionConfig: ExtensionConfigs = {};
  #extensions = new Set<string>();
  constructor(
    public customSetup: UserFunctions["setup"] = async () => {},
    public executeTask: UserFunctions["task"] = async () => {},
    public fetchSubmission: UserFunctions["submission"] = async () => "",
    public auditSubmission: UserFunctions["audit"] = async () => false,
    public makeDistributionList: UserFunctions["distribution"] = () => ({}),
    public setupRoutes: UserFunctions["routes"] = async () => {},
    public isInitialized = false,
  ) {}

  initialize(userFunctions: UserFunctions) {
    const [missingFunctions, notFunctions] = this.checkFunctions(userFunctions);
    if (missingFunctions.length > 0) {
      const functionPlural =
        missingFunctions.length > 1 ? "functions" : "function";
      throw new Error(
        `Missing required ${functionPlural}: ${missingFunctions.join("(), ")}()`,
      );
    }
    if (notFunctions.length > 0) {
      const functionPlural =
        notFunctions.length > 1 ? "functions" : "a function";
      throw new Error(`Not ${functionPlural}: ${notFunctions.join("(), ")}()`);
    }
    const { setup, task, submission, audit, distribution, routes } =
      userFunctions;
    this.customSetup = setup;
    this.executeTask = task;
    this.fetchSubmission = submission;
    this.auditSubmission = audit;
    this.makeDistributionList = distribution;
    this.setupRoutes = routes;
    this.isInitialized = true;
  }

  checkFunctions(userFunctions: UserFunctions): [string[], string[]] {
    const requiredFunctions = [
      "setup",
      "task",
      "submission",
      "audit",
      "distribution",
      "routes",
    ] as const;

    type RequiredFunction = (typeof requiredFunctions)[number];

    const missingFunctions: RequiredFunction[] = [];
    const notFunctions: RequiredFunction[] = [];

    for (const func of requiredFunctions) {
      if (!userFunctions[func]) {
        missingFunctions.push(func);
      } else if (typeof userFunctions[func] !== "function") {
        notFunctions.push(func);
      }
    }
    return [missingFunctions, notFunctions];
  }

  registerExtension(extension: string, config: ExtensionConfig) {
    this.#extensions.add(extension);
    this.#extensionConfig[extension] = config;
  }

  getExtensions() {
    return Array.from(this.#extensions);
  }

  hasExtension(extension: string) {
    return this.#extensions.has(extension);
  }
  getExtensionConfig(extension: string): ExtensionConfig {
    const config = this.#extensionConfig[extension];
    if (!config) {
      throw new Error(`Extension ${extension} is not registered.`);
    }
    return config;
  }
}

const taskManager = new TaskManager();

export function initializeTaskManager(userFunctions: UserFunctions): void {
  taskManager.initialize(userFunctions);
}

export async function getTaskManager(): Promise<TaskManager> {
  return new Promise((resolve, reject) => {
    if (taskManager.isInitialized) {
      resolve(taskManager);
      return;
    }
    const interval = setInterval(() => {
      if (taskManager.isInitialized) {
        clearInterval(interval);
        resolve(taskManager);
      }
    }, 100);
    setTimeout(() => {
      clearInterval(interval);
      reject(new Error("Task manager is not ready after 2 seconds."));
    }, 2000);
  });
}
